<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on The Terminal</title><link>https://0xlax.github.io/posts/</link><description>Recent content in Posts on The Terminal</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 05 Apr 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://0xlax.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>NES Emulator in Rust Part 1</title><link>https://0xlax.github.io/posts/nes-emulator-in-rust/</link><pubDate>Wed, 05 Apr 2023 00:00:00 +0000</pubDate><guid>https://0xlax.github.io/posts/nes-emulator-in-rust/</guid><description>
&lt;img src="https://www.copetti.org/images/consoles/nes/ppu_mario/nametable_marked.e0e520cc7636d1539f9798032e9c14882a79b49cadba9faf25bfece7ae19cbe3.png"/>
&lt;h3 id="why">
Why?
&lt;a href="#why" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h3>
&lt;p>For fun. moving on..&lt;/p>
&lt;h3 id="history">
History
&lt;a href="#history" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h3>
&lt;p>The Nintendo Entertainment System (NES) was first released in Japan in 1983 and quickly became a cultural phenomenon, selling millions of units worldwide. Over the years, many gamers have wanted to relive the nostalgia of playing their favorite NES games. This led to the development of NES emulators, which allow users to play NES games on their computers or other devices.&lt;/p>
&lt;p>The first NES emulator was called Pasofami and was developed by a Japanese programmer named Yuiichi Toyama in 1989. It was later released as freeware in 1995. However, Pasofami was not very accurate and had many compatibility issues.In 1996, a programmer named Marat Fayzullin released the first version of his emulator, VirtualNES. It was the first NES emulator to achieve a high level of accuracy and compatibility. This paved the way for many other developers to create their own NES emulators.One of the most popular NES emulators of all time is Nestopia. It was created by Martin Freij in 1997 and is still widely used today. Nestopia was known for its high accuracy and compatibility with many NES games. It was also the first emulator to support netplay, which allows users to play games with others over the internet.&lt;/p>
&lt;p>Another popular NES emulator is FCEUX, which stands for &amp;ldquo;FCE Ultra eXtended.&amp;rdquo; It was created by the FCE team in 2004 as an extension of the original FCE Ultra emulator. FCEUX is known for its advanced debugging features and its ability to emulate many different NES hardware configurations.&lt;/p>
&lt;p>In recent years, there has been a trend of developing NES emulators in new programming languages, such as Rust. Rust is a systems programming language that provides a good balance of performance and safety, making it an ideal choice for building emulators.&lt;/p>
&lt;h3 id="rust">
Rust
&lt;a href="#rust" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h3>
&lt;p>Rust is a modern systems programming language that offers a number of benefits for building an NES emulator. One of the main advantages of Rust is its focus on safety and performance. Rust&amp;rsquo;s type system ensures that your code is type-safe and memory-safe, reducing the risk of common programming errors like buffer overflows and null pointer dereferences. Additionally, Rust provides powerful abstractions for working with low-level hardware, such as the NES&amp;rsquo;s 6502 CPU and its various memory-mapped registers. This makes it easier to write clean and maintainable code, while still achieving high performance. However, to fully benefit from this series of posts, you&amp;rsquo;ll need to have a basic understanding of Rust concepts like ownership, borrowing, lifetimes, and macros.&lt;/p>
&lt;h3 id="nes-hardware-architecture">
NES Hardware Architecture
&lt;a href="#nes-hardware-architecture" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h3>
&lt;img src="https://0xlax.github.io/img/arch.png" alt="nesarch" class="center" />
&lt;p>Understanding the original NES hardware is quite important as it helps you develop foundational understanding of what you are going to build.
A cartridge is an actual game rom stored in physical cartridge which has a Program Rom to store game data and Character Rom to store grahics data.
CPU is the central processing unit (duh) of the NES. It&amp;rsquo;s a modified version of the 6502 CPU that runs at 1.79 MHz.
PPU is the chip responsible for generating the graphics and video output of the NES while PPU Registers are the registers in the PPU that control the generation of video output. Similarly with Audio and Audio Registers.
Lastly, controller revieces game imputs from game controller.&lt;/p>
&lt;p>Now that we are sure of whats inside. Its time to emulate. basically, We understand how the hardware works and we are going to build a customised emulator that replicates the working of the old NES hardware to read and run the binary ROMs and feel the retro gaming era. Now why are we doing all this? idk I was born in 2001 that&amp;rsquo;s why maybe? Moving on.&lt;/p>
&lt;h3 id="references">
References
&lt;a href="#references" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://www.nesdev.org/wiki/Nesdev_Wiki">Nesdev Wiki&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://lib.rs/emulators">Libraries&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Part2: [NES Emulator in Rust: CPU]&lt;/p></description></item><item><title>NES Emulator in Rust: CPU</title><link>https://0xlax.github.io/posts/nes-emulator-in-rust2/</link><pubDate>Wed, 05 Apr 2023 00:00:00 +0000</pubDate><guid>https://0xlax.github.io/posts/nes-emulator-in-rust2/</guid><description>
&lt;img src="https://www.copetti.org/images/consoles/nes/ppu_mario/nametable_marked.e0e520cc7636d1539f9798032e9c14882a79b49cadba9faf25bfece7ae19cbe3.png"/>
&lt;h3 id="cpu">
CPU
&lt;a href="#cpu" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h3>
&lt;p>In the &lt;a href="https://laxman.tech/posts/nes-emulator-in-rust/">previous post&lt;/a>, I gave a tiny introduciton on how NES hardware works which honestly is quite enough to start building. We are going to have to build each component so I will delve deeper into the workings of each as we build, starting with CPU.&lt;/p></description></item><item><title>Rise of Horizen</title><link>https://0xlax.github.io/posts/rise-of-horizen/</link><pubDate>Tue, 14 Jun 2022 00:00:00 +0000</pubDate><guid>https://0xlax.github.io/posts/rise-of-horizen/</guid><description>
&lt;img src="https://www.horizen.io/assets/img/icons/page_media/logo_no_tagline_dark.svg"/>
&lt;p>Ever since I watched the Consensus2022 presentation by &lt;a href="https://www.twitter.com/robviglione">Rob Viglione&lt;/a> about zkSNARKs, made me curious how Horizen plans its scalability. This blog is a short deep dive into Horizen Blockchain and relevent comparisions.&lt;/p>
&lt;h3 id="horizen-zen">
Horizen ($ZEN)
&lt;a href="#horizen-zen" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h3>
&lt;blockquote>
&lt;p>Horizen is a general-purpose blockchain system with novel Cross-Chain Transfer Protocol (CCTP) that enables an unbound and fully
decentralized sidechain ecosystem&lt;/p>
&lt;/blockquote>
&lt;p>A peer-to-peer, permissionless and incentivised network that enables you to build a custom blockchain and applicaiton on the layer using Sidechain-SDK, a development kit devised to deploy a blockchain with fully customisable features and Dapps using Horizen&amp;rsquo;s scalability and extenisbility. Multiple convocations of sidechains (parallel chains) transmit messages to each other and the mainchain via CCTP.&lt;/p>
&lt;p>As of writing, Horizen has 45k active nodes running with an stake requirement of 42 $ZEN at an average price of $15.08 and estimated earning per node of about $4.17 ($50.75 a year)&lt;/p>
&lt;p>Horizen has an intense focus on enabling zero-knowledge protocol to let application verify information without revealing the information itself. This helps companies building supply chains on Horizen share product data with customers without revealing sensitive information,
like identities of people involved in supply chain or locations of factories&lt;/p>
&lt;h2 id="internals-and-architecture">
Internals and Architecture
&lt;a href="#internals-and-architecture" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h2>
&lt;h4 id="equihashhttpsgithubcomtrompequihash">
&lt;a href="https://github.com/tromp/equihash">Equihash&lt;/a>
&lt;a href="#equihashhttpsgithubcomtrompequihash" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h4>
&lt;p>Horizen protocols focus on maximum functionality rather than design by following Bitcoin&amp;rsquo;s core alongside the &lt;a href="https://eprint.iacr.org/2015/946.pdf">Equihash Proof-of-Work&lt;/a> with &lt;a href="https://www.horizen.io/assets/files/A-Penalty-System-for-Delayed-Block-Submission-by-Horizen.pdf">Delayed block penalty algorithm&lt;/a>&lt;/p>
&lt;p>Equihash Proof of Work mining algorithm is a class of hash function like &lt;a href="https://eth.wiki/en/concepts/ethash/ethash">ETHash&lt;/a> solving computational intensive and memory intensive problems to generate the proof but in an instant. Nice trade ;)&lt;/p>
&lt;p>Equihash is also used by ZCash, Bitcoin Gold and known for being &lt;a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC-resistant&lt;/a>&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>Uses BLAKE2b to compute 50 MB hash dataset from the previous blocks in the blockchain (until the current block).&lt;/li>
&lt;li>Solves the &amp;ldquo;Generalized Birthday Problem&amp;rdquo; over the generated hash dataset (pick 512 different strings from 2097152, such that the binary &amp;gt;XOR of them is zero). The best known solution (Wagner&amp;rsquo;s algorithm) runs in exponential time, so it requires a lot of memory-intensive and &amp;gt;computing-intensive calculations.&lt;/li>
&lt;li>Double SHA256 the solution to compute the final hash.&lt;/li>
&lt;li>uses proof-of-stake consensus protocol since mining corporations consider &lt;a href="https://en.bitcoin.it/wiki/Mining_hardware_comparison">ASIC miners&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h4 id="cross-chain-transfer-protocol-cctp">
Cross-Chain Transfer Protocol (CCTP)
&lt;a href="#cross-chain-transfer-protocol-cctp" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h4>
&lt;img src="https://0xlax.github.io/img/cctp.png" alt="CCTP" class="center" />
&lt;p>The above self-explanatory image depicts how CCTP works i.e, providing safe and secure coin transfer invocations between mainchain and the sidechain. &amp;ldquo;Transfer&amp;rdquo; of coins in this scenario is a process of burning and recreating the coins under different chains (either mainchain to sidechain or vice versa) with same metadata attached regarding the end destinations. Just like a regular transactions as in Bitcoin and Ethereum, the chains use UTXO but with specific sidechain output (for initial transactions). A sidechain is a multi-feature customisable chain that runs parallel to the mainchain.&lt;/p>
&lt;p>Basically, a 2-way protocol that performs 2 operations:&lt;/p>
&lt;ul>
&lt;li>Forward Transfer&lt;/li>
&lt;li>Backward Transfer&lt;/li>
&lt;/ul>
&lt;p>All this might sounds familiar if you have been a cryptodev for a while&amp;hellip; COSMOS!&lt;/p>
&lt;p>Cosmos uses IBC (Inter Blockchain Communication protocol) and CosmosSDK while Horizon uses CCTP and SidechainSDK. Though the functionality between IBC and CCTP are similar with respect to multichain interoperability, there are vast differences between them which is explained later.&lt;/p>
&lt;h4 id="sidechains">
Sidechains
&lt;a href="#sidechains" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h4>
&lt;p>A Horizen sidechain architecture is built using 3 components. Based on the designed, components can be hight coupled or decoupled so it works independent from any particular sidechain implementation.&lt;/p>
&lt;ul>
&lt;li>Mainchain consensus protocol (MCP)&lt;/li>
&lt;li>Cross-Chain Transfer Protocol (CCTP)&lt;/li>
&lt;li>Sidechain Consensus protocol (SCP)&lt;/li>
&lt;/ul>
&lt;p>Multipurposeness in a sidechain can be achieved by designing a system so that MCP and SCP are completely &lt;a href="https://arxiv.org/abs/1812.05441">decoupled&lt;/a>.&lt;/p>
&lt;p>Check out &lt;a href="https://github.com/HorizenOfficial/Sidechains-SDK">SidechainSDK&lt;/a> to know more about building on Horizen&lt;/p>
&lt;p>Latus Sidechain is one among the many sidechains in existance that uses &lt;a href="https://eprint.iacr.org/2016/889.pdf">Ourobous POS&lt;/a> algorithm&lt;/p>
&lt;h4 id="ibc-vs-cctp">
IBC vs CCTP
&lt;a href="#ibc-vs-cctp" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Inter-BLockchain Communication (IBC)&lt;/th>
&lt;th>Cross-Chain Transfer Protocol (CCTP)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Communication between Zones as well as with Hub&lt;/td>
&lt;td>Modified version of CCTP called Zendoo for communication between mainchain and sidechains&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>IBC supports transport, authentication and ordering of layers&lt;/td>
&lt;td>CCTPs responsible for only forward and backward transfers&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>IBCBlockCommitTx and IBCPacketTx transactions are used to defined and verify sender and reciever&lt;/td>
&lt;td>CCTP leverages zkSnark techniques to esstablish decentralised and verifiable cros-chain transfers. Also, enables communication(burning and creation) with different sidechain without knowing their internal structure&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="references">
References
&lt;a href="#references" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h3>
&lt;p>&lt;a href="https://cryptobook.nakov.com/cryptographic-hash-functions/proof-of-work-hash-functions">cryptobook&lt;/a>
&lt;a href="https://www.horizen.io/assets/files/Horizen-White-Paper.pdf">Horizon Whitepaper&lt;/a>
&lt;a href="https://ibcprotocol.org/implementations">IBC&lt;/a>&lt;/p>
&lt;h5 id="a-submission-to-syndicaiohttpssyndicaio">
A submission to &lt;a href="https://syndica.io/">Syndica.io&lt;/a>
&lt;a href="#a-submission-to-syndicaiohttpssyndicaio" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h5></description></item><item><title>X25519 Elliptic Curve</title><link>https://0xlax.github.io/posts/x25519-elliptic-curve/</link><pubDate>Thu, 02 Jun 2022 20:20:36 +0530</pubDate><guid>https://0xlax.github.io/posts/x25519-elliptic-curve/</guid><description>
&lt;img src="https://hsto.org/webt/qy/r5/a6/qyr5a6ywaf8vbc2kxtaazdmvgz8.png"/>
&lt;!-- raw HTML omitted -->
&lt;p>x25519 is a fast, secure &lt;a href="#terminology">Curve25119 ECDH&lt;/a> function which lays the foundation of almost all field of software including Operating sytems, Network, TLS Libraries and Blockchains.&lt;/p>
&lt;blockquote>
&lt;p>An attacker who spends a billion dollars on special-purpose chips to attack Curve25519, using the best attacks available today, has about 1 chance in 1000000000000000000000000000 of breaking Curve25519 after a year of computation
â€” &lt;!-- raw HTML omitted -->&lt;a href="https://dnscurve.org/crypto.html">Dan Bernstien&lt;/a>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;/blockquote>
&lt;h3 id="x25519">
X25519
&lt;a href="#x25519" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h3>
&lt;p>To understand x255219, it is crucial to understand the underlying basics Elliptic Curve Cryptography, ECDH key exchange protocol, Curve25119 and coordinate based equations.&lt;/p>
&lt;p>Bernstein contructed the Diffie-Hellman Key exchange protocol &lt;em>X25519&lt;/em> based on Curve25519. As known from the Eliptic curve cryptography demonstrating how the coordinates are mapped to obtain a key, X25519 follows the same paradim but only depends on x coordinate of the point on the elliptic curve. This was source in through Victor Millier&amp;rsquo;s &lt;a href="%22https://link.springer.com/chapter/10.1007/3-540-39799-X_31%22">Use of Elliptic Curves in Cryptography&amp;quot;&lt;/a>&lt;/p>
&lt;p>Calculating a point based on x-coordinate and the curve equations is done is various ways- using the algebraic structure of the point group (the presence of the 4th order point) on the Montgomery curve is less computationally intensive with the Montgomery Ladder Algorithm and is easier to implement in constant time. This is why Bernstein chose the Montgomery curve.&lt;/p>
&lt;p>In the practical application of ECDH, top priority should be given to the check of messages received. In the typical ECDH protocol, both parties participating in the protocol will receive the temporary public key sent by the other party. To ensure security (to ensure their private key information will not leak), it is usually necessary to first check the legality of the received point.&lt;/p>
&lt;p>If the received point is the point deliberately constructed by the other party, the other party may steal the private key information through the interaction process of the ECDH protocol. If the check of the point is ignored, it may cause small subgroup attacks or invalid-curve attacks, etc.&lt;/p>
&lt;p>Similar problems exist in ECDH key exchange protocols that rely only on x coordinates. The difference is that it is more difficult to check the validity of the public key at this time, which is to determine whether the amount of received public key x calculated by the curve equation is the quadratic residual on the prime field. Since the square operation on the domain is a 2-to-1 mapping, only half of the x values are legal. In order to solve this problem, the design of the X25519 protocol innovatively takes into consideration the elliptic curve point group on the quadratic expansion domain, while considering the two elliptic curve point groups on the base domain and the quadratic expansion domain. Then the arbitrary value in the number field on the bottom layer can be used as a legal public key &amp;ndash; In the perspective of modulo operation, furthermore, any 32-byte array can be used as a legal public key value, thereby eliminating the need to check the validity of the public key. It is noteworthy that although the second expansion is introduced, all operations are still performed on the prime field of the underlying layer, that is, the introduction of the quadratic extension does not increase the computational complexity. Since the discrete logarithm remains difficult in the two curve point groups, the X25519 key exchange protocol is also safe.&lt;/p>
&lt;h3 id="applications">
Applications
&lt;a href="#applications" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h3>
&lt;ol>
&lt;li>Protocols:&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/QUIC">QUIC&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">TLS&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Secure_Shell">SSH&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://signal.org/blog/signal-inside-and-out/">Signal Protocol&lt;/a>&lt;/li>
&lt;/ul>
&lt;ol start="2">
&lt;li>Networks:&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>&lt;a href="https://www.torproject.org/">Tor&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.stellar.org/">Stellar&lt;/a>&lt;/li>
&lt;/ul>
&lt;ol start="3">
&lt;li>SSH Softwares&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>&lt;a href="https://github.com/connectbot/connectbot">ConnectBot â€” SSH client for Android&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gitlab.redox-os.org/redox-os/redox-ssh">redox-ssh â€” SSH Client and Server written in Rust&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.smartftp.com/">SmartFTP â€” an FTP, SSH, SFTP client&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/pts/pts-dropbear">pts-dropbear â€” Dropbear SSH tools with ed25519 and other improvements by pts&lt;/a>&lt;/li>
&lt;/ul>
&lt;ol start="4">
&lt;li>NaCl Libraries&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>&lt;a href="https://nacl.cr.yp.to/">NaCl Networking and Cryptography Library&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://pkg.go.dev/golang.org/x/crypto/nacl">PyNaCl&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://pkg.go.dev/golang.org/x/crypto/nacl">Go: NaCl port&lt;/a>&lt;/li>
&lt;/ul>
&lt;ol start="5">
&lt;li>Crypto Libraries&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>&lt;a href="https://pkg.go.dev/golang.org/x/crypto/curve25519">Go: curve25519&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/jeff-r-koyaltech/curve25519-uwp">C++: curve25519-uwp&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://cr.yp.to/ecdh.html">DJB&amp;rsquo;s Implementation&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/dalek-cryptography/x25519-dalek">Rust: X25519-dalek&lt;/a>&lt;/li>
&lt;/ul>
&lt;ol start="6">
&lt;li>TLS Libraries&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>&lt;a href="https://www.libressl.org/">LibreSSL&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gnutls.org/">GnuTLS&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/rustls/rustls">rustls&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/tlsfuzzer/tlslite-ng">tlslite-ng â€” an open source python library that implements SSL and TLS cryptographic protocols&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/turbo/nuTLS">nuTLS â€” Minimal, modern, dependency-free TLS server / client library for Linux&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="terminology">
Terminology
&lt;a href="#terminology" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>&lt;em>&lt;strong>Curve25519&lt;/strong>&lt;/em> : Curve25519 is a Montgomery curve built by Bernstein in 2006, in which 25519 indicates that the characteristic of the bottom prime number field on which the elliptic curve depends is 2Â²âµâµ-19&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;em>&lt;strong>Ed25519&lt;/strong>&lt;/em> Ed25519 is the EdDSA signature scheme using SHA-512&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;em>&lt;strong>Diffie-Hellmman Key Exchange&lt;/strong>&lt;/em> is a commonly used exchainge protocol which lets 2 different parties having a key pair exchain information through a insecure channel in a secure way without being eavesdropped by a third party. Once of my favourite source for understanding ECDH key exchange better is to watch this detailed explanation by &lt;a href="https://www.youtube.com/user/Computerphile">Computerphile&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/NmM9HA2MQGI" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;ul>
&lt;li>&lt;em>&lt;strong>Curve25519&lt;/strong>&lt;/em> Curve25519 is a Montgomery Cruve built by Dan Bernstien in 2006, in which 25519 indicated that characteristic of the bottom prome number field on which the elliptic curve depends in &lt;strong>2&lt;!-- raw HTML omitted -->255&lt;!-- raw HTML omitted --> - 19&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h4 id="references">
References
&lt;a href="#references" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h4>
&lt;p>&lt;a href="https://github.com/longcpp/CryptoInAction/blob/master/intro-ed25519/190902-intro-x25519.pdf">intro-ed25519&lt;/a>
&lt;a href="https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman">ECDH protocol&lt;/a>&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted --></description></item><item><title>Eth2, The Merge and L1s</title><link>https://0xlax.github.io/posts/eth2-vs-l1-metrics/</link><pubDate>Wed, 01 Jun 2022 16:59:52 +0530</pubDate><guid>https://0xlax.github.io/posts/eth2-vs-l1-metrics/</guid><description>
&lt;img src="https://ethereum.org/static/5d3af9eb308978e7a078bf51022d8a5c/24462/merge.webp"/>
&lt;h3 id="introduction">
Introduction
&lt;a href="#introduction" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h3>
&lt;p>Prices of L1s are known to be volatile and its hard to spin a number on its valuation. Instead, using metrics as Total Value Locked, number of transactions and users count we will see the comparision of Eth2 with other L1s. With Ethereumâ€™s upcoming transition from Proof of Work (POW) to Proof of Stake (POS), we can now use staking yields as a basis of comparison across all Layer-1 tokens.&lt;/p>
&lt;h3 id="the-merge-">
The Merge ðŸ¼
&lt;a href="#the-merge-" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h3>
&lt;p>&lt;img src="https://pbs.twimg.com/media/FSkMcTDVEAEFsAR?format=png&amp;amp;name=small" alt="Panda for context">&lt;/p>
&lt;p>The Beacon Chain, a Ethereum POS network has been running parallel with Ethereum since December 2020. The transition from POW consensus to POS has been awaited and anticipated by many. On the merge, the Ethereum&amp;rsquo;s POW consensus layer will be removed and all future blocks on Ethereum are expected and will be achieved by the then merged Beacon Chain&amp;rsquo;s POS Consensus layer.&lt;/p>
&lt;p>The Ethereum team has been workign on making this happen along with series of other tests and conducts that regulate the process and safety after the merge including the &lt;a href="https://blog.ethereum.org/2022/03/14/kiln-merge-testnet">Kiln public testnet Merge&lt;/a> in March and the most recent &lt;a href="https://twitter.com/sassal0x/status/1524756386063667200?s=20&amp;amp;t=QZIo6qDUhC8ySoYwtfDbvA">4th shadow fork&lt;/a>&lt;/p>
&lt;blockquote class="twitter-tweet">&lt;p lang="en" dir="ltr">Ethereumâ€™s Merge is coming&lt;br>&lt;br>Hereâ€™s what you need to know, explained simply.&lt;br>&lt;br>ðŸ§µ&lt;/p>&amp;mdash; Jack Niewold ðŸ«¡ (@JackNiewold) &lt;a href="https://twitter.com/JackNiewold/status/1506779959242764288?ref_src=twsrc%5Etfw">March 23, 2022&lt;/a>&lt;/blockquote>
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8">&lt;/script>
&lt;blockquote>
&lt;p>Merge is expected to happen in Q3/Q4 2022.&lt;/p>
&lt;/blockquote>
&lt;p>The important takeaway from the Merge is that it does not help scale Ethereum! If so what is the point then?&lt;/p>
&lt;ul>
&lt;li>Proof-of-Work concensus has a laborious requirement of energy. Miners running nodes in a POW system use powerful GPUs that requires vast amount of electricity to run the calculations and cryptographic puzzles - hashing algorithms that so as to keep the network and funds secure. Comparatively, any recent consumer hardware is capable of being ETH2 validator. And pushing a node to the network to participare in network&amp;rsquo;s consensus algorithm with a minimum stake requirements of 32 ETH and if incase any sort of malicious activities by the validatos leads to &lt;a href="https://consensys.net/knowledge-base/ethereum-2/glossary/#slashing">slashing&lt;/a> of their staked funds.&lt;/li>
&lt;/ul>
&lt;p>In addition, since POW requires expensive hardware and electricity costs, ETH token inflation has been around 4.3% per year to compensate the miners for their work. With POS being more energy-efficient, the cost to secure the Ethereum network (token inflation) is much less. Ethereumâ€™s POS issuance model is based on how much ETH is being staked. Currently, there are about 12.5M ETH staked on the Beacon Chain â€“ at that level, annual issuance would be about 0.5%.&lt;/p>
&lt;p>Although, this new merge is giving out opportunities to develop many Proof-of-Stake distruibuted validator layer protocols and middleware clients. that enables you to run validators across other independent nodes safely. Like, &lt;a href="https://github.com/ObolNetwork/charon">Charon&lt;/a> from &lt;a href="https://obol.tech">Obol Labs&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>Charon integrates into the Ethereum consensus stack as a middleware between the validator client and the beacon node via the official Eth Beacon Node REST API. Charon supports any upstream beacon node that serves the Beacon API. Charon supports any downstream standalone validator client that consumes the Beacon API.&lt;/p>
&lt;/blockquote>
&lt;p>One of the advantage of Chaon is you that you can participate in the network&amp;rsquo;s consensus by staking only half the required stake amounts and eark equivalent rewards on your validator nodes.&lt;/p>
&lt;h3 id="eth-staking">
ETH Staking
&lt;a href="#eth-staking" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h3>
&lt;p>An yield return depends on the ETH staked which drives the staking returns&lt;/p>
&lt;ul>
&lt;li>
&lt;h4 id="yields-based-on-eth-staked">
Yields based on ETH staked
&lt;a href="#yields-based-on-eth-staked" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h4>
&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>ETH Staked&lt;/th>
&lt;th>Max Annual Issuarance (ETH)&lt;/th>
&lt;th>Max Annual Issurance in %&lt;/th>
&lt;th>Staking Yield %&lt;/th>
&lt;th>Annual Burn (ETH)&lt;/th>
&lt;th>Real Staking Yield %&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>1,000,000&lt;/td>
&lt;td>&lt;strong>181,019&lt;/strong>&lt;/td>
&lt;td>&lt;code>0.15%&lt;/code>&lt;/td>
&lt;td>&lt;code>18.10%&lt;/code>&lt;/td>
&lt;td>&lt;strong>-3,012,400&lt;/strong>&lt;/td>
&lt;td>&lt;code>69.68%&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3,000,000&lt;/td>
&lt;td>&lt;strong>313,534&lt;/strong>&lt;/td>
&lt;td>&lt;code>0.26%&lt;/code>&lt;/td>
&lt;td>&lt;code>10.45%&lt;/code>&lt;/td>
&lt;td>&lt;strong>-3,012,400&lt;/strong>&lt;/td>
&lt;td>&lt;code>29.10%&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>10,000,000&lt;/td>
&lt;td>&lt;strong>572,433&lt;/strong>&lt;/td>
&lt;td>&lt;code>0.47%&lt;/code>&lt;/td>
&lt;td>&lt;code>5.72%&lt;/code>&lt;/td>
&lt;td>&lt;strong>-3,012,400&lt;/strong>&lt;/td>
&lt;td>&lt;code>12.66%&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>12,500,000&lt;/td>
&lt;td>&lt;strong>624,814&lt;/strong>&lt;/td>
&lt;td>&lt;code>0.52%&lt;/code>&lt;/td>
&lt;td>&lt;code>5.00%&lt;/code>&lt;/td>
&lt;td>&lt;strong>-3,012,400&lt;/strong>&lt;/td>
&lt;td>&lt;code>10.92%&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>30,000,000&lt;/td>
&lt;td>&lt;strong>991,483&lt;/strong>&lt;/td>
&lt;td>&lt;code>0.82%&lt;/code>&lt;/td>
&lt;td>&lt;code>3.30%&lt;/code>&lt;/td>
&lt;td>&lt;strong>-3,012,400&lt;/strong>&lt;/td>
&lt;td>&lt;code>6.62%&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>42,000,000&lt;/td>
&lt;td>&lt;strong>1,131,833&lt;/strong>&lt;/td>
&lt;td>&lt;code>0.94%&lt;/code>&lt;/td>
&lt;td>&lt;code>2.69%&lt;/code>&lt;/td>
&lt;td>&lt;strong>-3,012,400&lt;/strong>&lt;/td>
&lt;td>&lt;code>5.43%&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>66,000,000&lt;/td>
&lt;td>&lt;strong>1,412,534&lt;/strong>&lt;/td>
&lt;td>&lt;code>1.17%&lt;/code>&lt;/td>
&lt;td>&lt;code>2.14%&lt;/code>&lt;/td>
&lt;td>&lt;strong>bo-3,012,400&lt;/strong>&lt;/td>
&lt;td>&lt;code>4.21%&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h5 id="sourcehttpsdocsethhubioethereum-roadmapethereum-20eth-20-economics">
&lt;a href="https://docs.ethhub.io/ethereum-roadmap/ethereum-2.0/eth-2.0-economics/">source&lt;/a>
&lt;a href="#sourcehttpsdocsethhubioethereum-roadmapethereum-20eth-20-economics" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h5>
&lt;p>The above table estimations are upped with few assumptions excluding MEV, with the current ETH staked on Beacon chain(~10% supply, 12.5M ETH).&lt;/p>
&lt;ul>
&lt;li>
&lt;h4 id="eth-staking-yields-vs-competing-l1s">
ETH Staking Yields vs Competing L1s
&lt;a href="#eth-staking-yields-vs-competing-l1s" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h4>
&lt;/li>
&lt;/ul>
&lt;p>Looking at nominal yields, ETH is about middle of the pack compared to its major competitors, with yields ranging from 6.64% to 17.53% in nominal terms. However, with the exception of BNB, all of the other tokens in the competitive set are inflationary. Factoring in token issuance rates, ETH has the highest staking returns on a real yield basis.&lt;/p>
&lt;p>&lt;img src="https://lh4.googleusercontent.com/o0QJVZxOnt2JbuviicoFDC9570ZMkG-96ENyia3HAYT8wdLAPoblP1CtSqD0n1smRHo7SxhPdE8YSM9Ji6CpG-agF2mXWNkepqUroxJ7L4FFZkyxQQ9AkLPlCuQFJD7TddFPrnyd0J_-myYf-Q" alt="l1">&lt;/p>
&lt;p>One point to note is that currently only 10.3% of ETH is staked on the Beacon Chain, which is the lowest in the competitive set and likely due to concerns about locking up ETH for a long time (withdrawals are not possible currently). Staking should increase post-Merge as the execution risk of the Merge is removed, ETH moves closer to enabling staking withdrawal, and more people grow comfortable with staking ETH. Staking participation amongst competing L1s ranges from 35% to 76% with an average of 55%. If ETH staking participation increases to the average of 55%, real staking yields for ETH would likely decrease to approximately 4.21%. At 55% of supply staked, ETHâ€™s real yield would project to be higher than SOL, AVAX and MATIC, but lower than BNB, DOT, NEAR and FTM&lt;/p>
&lt;p>After factoring in projected increases to circulating supply over the next year for the competitive set, ETHâ€™s real staking yield net of dilution is the highest if we assume staking participation remains the same. If ETHâ€™s staking participation reaches 55%, then ETH would rank higher than SOL, AVAX, NEAR and MATIC but lower than BNB, DOT and FTM.&lt;/p></description></item></channel></rss>